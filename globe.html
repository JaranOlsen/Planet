<!doctype html>
<html>

<!--
Copyright 2017-21, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 6 Aug 2021
This program demonstrates:
1. How to use great circle navigation to show a route around the earth.
2. How to set up orientation of object so that travel using only rotation.x
The input variables are the waypoints, latitude and longitude.
A trip includes 1 or more flights.
For each flight, the program calculates the distance and direction to the destination.
The program then shows the course using a series of line segments
ENHANCEMENTS
Day and night
Earth at 0,0 for skybox
Sun is fixed, Earth rotates
Camera fixed to Earth
TO DO
Camera at fixed location over moving object (can still modify with mouse)
* This requires computing heading and pitch for object
-->

<head>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<title>GreatCircle</title>
<link rel="stylesheet" href="styles/body2i.css">

</head>

<body>
<script src="js/three.min.js"></script>
<script src="js/WebGL.js"></script>
<script src="js/loaders/OBJLoader.js"></script>
<script src="js/loaders/GLTFLoader.js"></script>
<script src="js/objects/Lensflare.js"></script>

<!-- MAKE CHANGES STARTING HERE ******************************************* -->

<!-- Make Changes to Text Here ******************************************** -->

<div class="container">
	<div class="overlay1">
		<div>WICHITA TO TINIAN</div>
		<p></p>
		<div>Speed......: <span id="AC_Sped"></span> mph</div>
		<div>Heading....: <span id="AC_Bank"></span> deg</div>
		<div>Position...: <span id="AC_Lat1"></span>N <span id="AC_Lon1"></span>E</div>
		<div>GMT Time...: <span id="TYM_GMT"></span></div>
	</div>
	<div class="overlay2">
		<div>Current Date.: <span id="TYM_DAY"></span> <span id="TYM_MON"></span> <span id="TYM_ANN"></span></div>
		<div>Local Time...: <span id="TYM_LCL"></span> <span id="TYM_AMP"></span></div>
		<div><span id="NARwhat"></span> <span id="NARwher"></span> <span id="NARwhen"></span> <span id="NARampm"></span></div>
		<div>Flight Time..: <span id="TYM_Flt"></span></div>
		<div>Total Time...: <span id="TYM_Trp"></span></div>		
	</div>	
	<div class="overlay3">
		<div><span id="On_Info01"></span></div>
	</div>
	<div class="overlay4">
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
	</div>
</div>

<script>

/* = Flight Data ============================================================*/

var DATday = 15;	// Day
var DATmon = 1;		// Month
var DATann = 1945;	// Year

var fltDAT = [
	37.6872, -97.3301, "WICHITA KS", 0,				// Wichita, KS [KICT]
	38.5637, -121.2972, "MATHER FIELD CA", 5*60,	// Mather Field, CA [KMHR]
	21.5796, -158.2104, "DILLINGHAM FIELD HI", 5*60,	// Dillingham Field, HI [PHDH]
	8.7207, 167.7314, "KWAJELEIN ISLAND", 5*60,		// Bucholz Army Airfield, Kwajalein, KMR [PKWA]
	15.0699, 145.6364, "TINIAN ISLAND", 0			// Tinian Airport, MNP [PGWT]
	];

// Offsets	
var DATlat = 0;
var DATlon = 1;
var DATnam = 2;
var DATlnd = 3;
// Entries per Line
var DATlin = 4;

// Start Time and Degrees
var GMThrs = 12+6;								// Wichita 12PM  + 6
//	GMThrs = 0;

// Initial Value for Narrative
// Variables
var LCLhrs = 12;
var LCLstd = 12;
var LCLamp = "PM";
var ACland = 0;

var yrdays = 0;

/* = Constants ==============================================================*/
// Math Predefined
var PieVal = Math.PI;							// PI
var DegRad = PieVal / 180;						// Convert Degrees to Radians
var RadDeg = 180 / PieVal;						// Convert Radians to Degrees
// Starting Positions and Speeds (Degrees per Day)
var addhrs = .01;								// Increment in hours
var axeang = 23.44;
var axemax = 365.25
	axemax = 360;								// Simplified
var axersp = 360/axemax;
var earrsp = 360;
var axmang = 5.145;
var axmmax = 6585.321;
var axmrsp = 360/axmmax;
var munmax = 29.530588853;
	munmax = 30;								// Simplified
var munrsp = 360/munmax;
var airspd = 250;								// Aircraft speed = distance per hour
var airrsp = 360*airspd/24901;					// Aircraft degrees per hour
// Days
var	axeday = 9 + 30*(DATmon-1) + DATday;		// Estimated days in year so far beyond preceding winter solstice
var GMTday = GMThrs/24;							// Starting fraction of day
var axmday = 4852;								// days since last major lunar standstill
var munday = 15; 								// days since last full moon (Dec 29  14:38)
// Starting Rotations (used to position camera)
var	axerot = Mod360(axeday*axersp);				// 0 = Dec 22
var	earrot = Mod360(GMTday*earrsp);				// Earth starting rotation due to time
var axmrot = Mod360(axmday*axmrsp);
var	munrot = Mod360(munday*munrsp);
// Camera
var camrad = 50;
var camlat = fltDAT[DATlat];
// Start lon = -97.3301;
// At GMT = 17, GMTdeg = 165;
var camlon = Mod360(earrot+fltDAT[DATlon]+90);
// Drawing
var radisE = 25;								// Radius
var	radius = 25.1;								// Radius of routes
var segmnt = 2048;								// Segments
var sgment = segmnt / 24901;					// Segments per mile
var radisM = 8;									// Radius of Moon
var orbitM = 300;								// Orbit of Moon
var orbitS = 500;								// Orbit of Sun
// Keys
var	K_Info = 73;								// Info (i)
var	K_Paws = 80;								// Pause (p)

// Month Data
var monDAT = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var mdyDAT = [31,28,31,30,31,30,31,31,30,31,30,31];
if (Math.floor(DATann/4)==DATann/4) mdyDAT[1] = 29;	// Leap year

/* = Variables ==============================================================*/
// GLTF Models
var	airobj = 0;
// Objects
var geometry, material, texture, specular, mesh, fname;
// Routes
var lat1, lat2, lon1, lon2;						// Segment inputs
var latX = 0;									// Set default value
var lonX = 0;
var segdst = 0;									// Segment distance
var GCdist, GChdng, sgunit;						// Segment variables
// Camera
var camraX, camraY, camraZ;
var onMouseDownMouseX, onMouseDownMouseY, onMouseDownLon, onMouseDownLat;
// Flags
var PawsOn = 0;									// Pause
var EndFlg = 0;									// End
var InfoOn = 0;									// Info
// Flight Hours
var FLThrs = 0;									// Flight time
var TRPhrs = 0;									// Trip time

/* Aircraft Data - Start of Each Flight ------------------------------------------------------------------ */
var	PPBank = 0;
var	PHBank = 0;									// PHBank - (rotation.z = 90 - A) fixed
var	PPHed1 = 0;									// PPHead Beg - (rotation.y = lon1 - b) fixed
var PPHed2 = 0;									// PPHead End - (rotation.y = lon1 - b) new
var	PPPtch = 0;									// PPPtch - (rotation.x = c) changes
var	ACBank = 0;									// Headng - (relative to vertical) changes
var HXDRef = 0;
var PPPBeg = 0;									// PPPtch at beginning of flight
// Variables
var ACLat1 = 0;
var ACLon1 = 0;
// Radians
var PHB, PPP, PPH, ACB, ACP, HXD;

/* Routes ------------------------------------------------------------------ */
var flttot = fltDAT.length/DATlin;				// Number of flights in trip
// Flight
var fltcnt = 0;									// Flight counter
var fltsmi = 0;									// miles in flight
var flthdg = [0];								// Heading of each flight
	flthdg[flttot] = 0;
var fltdst = [0];								// Distance of each flight
	fltdst[flttot] = 0;
// Text and Numbers
var chrtot = 94;								// Total number of characters available
var chrtxt = [0];								// Number and text textures
	chrtxt[chrtot] = 0;
var fltlbl = [0];								// Spaces for distance characters
	fltlbl[7*flttot] = 0;						// 7 characters max for each distance
var	fltlbX;										// starting position for each flight
var	fltlbY;
var	fltlbZ;
var plclbl = [0];								// Room for place name characters
	plclbl[flttot*25] = 0;						// 25 characters max for each place name

/* = Basic Values ===========================================================*/

// Display
// var container = document.createElement("container");
// The variables "Canvas" and "WebGL" are defined in WebGL.js.
var scene = new THREE.Scene();
var target = new THREE.Vector3(); // center - used for sound, etc.
var width  = window.innerWidth, height = window.innerHeight;
var	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize(width, height);
window.addEventListener("resize", onWindowResize, false);
document.body.appendChild(renderer.domElement);
// Ambient Light
var light = new THREE.AmbientLight(0x404040);
scene.add(light);
// Sun
var sun = new THREE.DirectionalLight(0xffffff);
sun.position.set(0,0,-orbitS);
scene.add(sun);
// Camera
var camera = new THREE.PerspectiveCamera(45, width/height, 1, 20000);
	camera.position.z = -camrad;
	camera.rotation.y = 180*DegRad;				// Default = looking in
var camobj = new THREE.Object3D();				// Use this to rotate camera
	camobj.rotation.order = "YXZ";
	camobj.add(camera);
// Inputs
document.addEventListener("mousedown", onDocumentMouseDown, false);
document.addEventListener("mouseup", onDocumentMouseUp, false);
document.addEventListener("mousemove", onDocumentMouseMove, false);
document.addEventListener('mousewheel', onDocumentMouseWheel, {capture: false, passive: false});
document.addEventListener("touchstart", onDocumentTouchStart, false);
document.addEventListener("touchmove", onDocumentTouchMove, false);
document.addEventListener("touchend", onDocumentTouchEnd, false);
document.addEventListener("keydown", onDocumentKeyDown, false);
document.addEventListener("keyup", onDocumentKeyUp, false);

var isUserInteracting = false;						// Initial value
// Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
var loadingManager = new THREE.LoadingManager();
var RESOURCES_LOADED = false;
loadingManager.onLoad = function(){
	console.log("loaded all resources");
	RESOURCES_LOADED = true;
};
var	gltfLoader = new THREE.GLTFLoader(loadingManager);
var	loader = new THREE.TextureLoader(loadingManager);
// Wait Screen
var loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, width/height, 0.1, 100),
	box: 0
};
var boxrot = 0;

/* 3D Objects and Links  ---------------------------------------------------- */
// Earth Group
var earobj = new THREE.Object3D();				// Earth
	earobj.rotation.y = Mod360(earrot+axerot)*DegRad;
	earobj.add(camobj);							// Link camera to earth
var skyobj = new THREE.Object3D();				// Sky
var axeobj = new THREE.Object3D();				// Earth Rotation Axis
	axeobj.rotation.order = "YXZ";
	axeobj.rotation.x = axeang * DegRad;		// Inclination
	axeobj.rotation.y = Mod360(axerot)*DegRad;
	axeobj.add(earobj);
	axeobj.add(skyobj);
	scene.add(axeobj);
var atmobj = new THREE.Object3D();				// Earth Atmosphere
	scene.add(atmobj);
// Moon Group
var munobj = new THREE.Object3D();				// Moon
	munobj.rotation.y = Mod360(munrot+axerot-axmrot)*DegRad;
var	axmobj = new THREE.Object3D();				// Moon Orbit Angle
	axmobj.rotation.order = "YXZ";
	axmobj.rotation.x = axmang*DegRad;			// Inclination
	axmobj.rotation.y = Mod360(axmrot-axerot)*DegRad;	// Rotation
	axmobj.add(munobj);
	scene.add(axmobj);
// Trip
var	trpadr = new THREE.Object3D();
	earobj.add(trpadr);							// Link to Earth
		
/* HTML Overlay Text -------------------------------------------------------- */
var TYM_DAYElement = document.getElementById("TYM_DAY");
var TYM_DAYNode = document.createTextNode("");
TYM_DAYElement.appendChild(TYM_DAYNode);
var TYM_MONElement = document.getElementById("TYM_MON");
var TYM_MONNode = document.createTextNode("");
TYM_MONElement.appendChild(TYM_MONNode);
var TYM_ANNElement = document.getElementById("TYM_ANN");
var TYM_ANNNode = document.createTextNode("");
TYM_ANNElement.appendChild(TYM_ANNNode);
var TYM_GMTElement = document.getElementById("TYM_GMT");
var TYM_GMTNode = document.createTextNode("");
TYM_GMTElement.appendChild(TYM_GMTNode);
var TYM_LCLElement = document.getElementById("TYM_LCL");
var TYM_LCLNode = document.createTextNode("");
TYM_LCLElement.appendChild(TYM_LCLNode);
var TYM_AMPElement = document.getElementById("TYM_AMP");
var TYM_AMPNode = document.createTextNode("");
TYM_AMPElement.appendChild(TYM_AMPNode);
var AC_SpedElement = document.getElementById("AC_Sped");
var AC_SpedNode = document.createTextNode("");
AC_SpedElement.appendChild(AC_SpedNode);
var AC_Lat1Element = document.getElementById("AC_Lat1");
var AC_Lat1Node = document.createTextNode("");
AC_Lat1Element.appendChild(AC_Lat1Node);
var AC_Lon1Element = document.getElementById("AC_Lon1");
var AC_Lon1Node = document.createTextNode("");
AC_Lon1Element.appendChild(AC_Lon1Node);
var AC_BankElement = document.getElementById("AC_Bank");
var AC_BankNode = document.createTextNode("");
AC_BankElement.appendChild(AC_BankNode);
var TYM_TrpElement = document.getElementById("TYM_Trp");
var TYM_TrpNode = document.createTextNode("");
TYM_TrpElement.appendChild(TYM_TrpNode);
var TYM_FltElement = document.getElementById("TYM_Flt");
var TYM_FltNode = document.createTextNode("");
TYM_FltElement.appendChild(TYM_FltNode);
// Narrative: What
var NARwhatElement = document.getElementById("NARwhat");
var NARwhatNode = document.createTextNode("");
NARwhatElement.appendChild(NARwhatNode);
// Narrative: Where
var NARwherElement = document.getElementById("NARwher");
var NARwherNode = document.createTextNode("");
NARwherElement.appendChild(NARwherNode);
// Narrative: When
var NARwhenElement = document.getElementById("NARwhen");
var NARwhenNode = document.createTextNode("");
NARwhenElement.appendChild(NARwhenNode);
// Narrative: When
var NARampmElement = document.getElementById("NARampm");
var NARampmNode = document.createTextNode("");
NARampmElement.appendChild(NARampmNode);
// Info
var On_Info01Element = document.getElementById("On_Info01");
var On_Info01Node = document.createTextNode("");
On_Info01Element.appendChild(On_Info01Node);
var On_Info02Element = document.getElementById("On_Info02");
var On_Info02Node = document.createTextNode("");
On_Info02Element.appendChild(On_Info02Node);
var On_Info03Element = document.getElementById("On_Info03");
var On_Info03Node = document.createTextNode("");
On_Info03Element.appendChild(On_Info03Node);
var On_Info04Element = document.getElementById("On_Info04");
var On_Info04Node = document.createTextNode("");
On_Info04Element.appendChild(On_Info04Node);

// Initial Narrative Values
NARwhatNode.nodeValue = "Depart";
NARwherNode.nodeValue = fltDAT[DATnam];
NARwhenNode.nodeValue = HHMM(LCLstd*60);
NARampmNode.nodeValue = LCLamp;

/* = Main Program ===========================================================*/

if (THREE.WEBGL.isWebGLAvailable()) {
	// Initiate function or other initializations here
	initAll();
	rendAll();
} else {
	var warning = THREE.WEBGL.getWebGLErrorMessage();
	document.getElementById("container").appendChild(warning);
}

/* 1 Initialize =============================================================*/

function initAll() {
	// Default Text Values
	On_Info01Node.nodeValue = "Press I for Info";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	// Waitscreen for Objects
	WaitScreen();								// Load loading screen
	// Create the Heavens and the Earth
	loadSkyBox();								// Load skybox
	makeEarth1();								// Make earth
	makeMoony1();								// make moon
	makeSunny1();								// Let there be light
	// Routes
	compAllFlt();								// Compute heading and distance for each flight
	showAllFlt();								// Show routes
	// Object
	loadAirPln();								// Load airplane
	// Print Information
	loadFontAr();								// Load Arial fonts 
	showFltDst();								// Show flight distances
	showPlaces();								// Show place names
	// Camera
	moveCamera();								// Move camera
}

/* Wait Screen ==============================================================*/

// Wait Screen
function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	geometry = new THREE.PlaneGeometry(1,1);
	texture = loader.load("fx/prop.jpg");
	material = new THREE.MeshBasicMaterial({map: texture});
	loadingScreen.box = new THREE.Mesh(geometry, material);
	loadingScreen.box.rotation.set(PieVal,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

/* Load SkyBox ==============================================================*/

function loadSkyBox() {
	// SkySphere	
	geometry = new THREE.SphereBufferGeometry(16000, 256, 256);
	material = new THREE.MeshBasicMaterial({
		map:loader.load("sky/box/milkyway/milkyway4k.jpg"),
		side: THREE.BackSide
	});
	mesh = new THREE.Mesh(geometry, material);
	mesh.rotation.y = 180*DegRad;
	skyobj.add(mesh);
}

/* Make Earth and Moon ======================================================*/

// Make Earth
function makeEarth1() {
	geometry = new THREE.SphereBufferGeometry(radisE, 128, 128);
	texture = loader.load("texture/earth8k.jpg");
	specular = loader.load("texture/earthspec1k.jpg");
	material = new THREE.MeshPhongMaterial({map: texture, specularMap: specular});
	material.reflectivity = 1;
	material.shininess = 100;
	mesh = new THREE.Mesh(geometry, material);	
	mesh.rotation.y = 270 * DegRad;				// This fixes Prime Meridian
	earobj.add(mesh);
	showEquatr();								// Show equator
	showPrimeM();								// Show prime meridian
	// Atmosphere
	geometry = new THREE.SphereBufferGeometry(radisE+.2, 128, 128);
	material = new THREE.MeshPhongMaterial({color: 0x87ceeb, transparent: true, opacity: 0.3});
	mesh = new THREE.Mesh(geometry, material);
	atmobj.add(mesh);
}

// Equator
function showEquatr() {
	var positions = [];
	for (var i = 0; i <= segmnt; i++) {
		var theta = (i / segmnt) * PieVal * 2;
		positions.push(Math.sin(theta) * radius, 0, -Math.cos(theta) * radius);
	}
	geometry = new THREE.BufferGeometry();
	geometry.setAttribute(
		'position',
		new THREE.BufferAttribute(new Float32Array(positions),3)
	);
	material = new THREE.LineBasicMaterial({color: 0x0000ff});
	var latobj = new THREE.Line(geometry, material);
	earobj.add(latobj);							// Link to Earth
}

// Prime Meridian
function showPrimeM() {
	var positions = [];
	for (var i = 0; i <= segmnt; i++) {
		var theta = (i / segmnt) * PieVal * 2;
		positions.push(0, Math.sin(theta) * radius, -Math.cos(theta) * radius);
	}
	geometry = new THREE.BufferGeometry();
	geometry.setAttribute(
		'position',
		new THREE.BufferAttribute(new Float32Array(positions),3)
	);
	material = new THREE.LineBasicMaterial({color: 0x0000ff});
	var lonobj = new THREE.Line(geometry, material);
	earobj.add(lonobj);							// Link to Earth
}

/* Make Moon ================================================================*/

function makeMoony1() {
	geometry = new THREE.SphereBufferGeometry(radisM, 16, 16);
	texture = loader.load("texture/moon1k.jpg");
	material = new THREE.MeshPhongMaterial({map: texture});
	material.reflectivity = 0.5;
	material.shininess = 15;
	mesh = new THREE.Mesh(geometry, material);	
	mesh.position.z = orbitM;
	munobj.add(mesh);
}

/* Make Sun ================================================================*/

function makeSunny1() {
	// Lens Flare - Load Textures
	textureFlare0 = loader.load("sky/fx/lensflare1.png");
	textureFlare1 = loader.load("sky/fx/hexangle.png");
	// Lens Flare - Activate
	lensFlare = new THREE.Lensflare();
	lensFlare.addElement(new THREE.LensflareElement(textureFlare0, 512, 0));
	lensFlare.addElement(new THREE.LensflareElement(textureFlare1, 32, 0.2));
	lensFlare.addElement(new THREE.LensflareElement(textureFlare1, 64, 0.5));
	lensFlare.addElement(new THREE.LensflareElement(textureFlare1, 256, 0.9));
	sun.add(lensFlare);
}

/* Compute Heading and Distance for Each Flight =============================*/

function compAllFlt() {
	// For Each Flight
	for (var i = 0; i < flttot; i++) {
		lat1 = fltDAT[i*DATlin+DATlat], lon1 = fltDAT[i*DATlin+DATlon];
		lat2 = fltDAT[i*DATlin+DATlin+DATlat], lon2 = fltDAT[i*DATlin+DATlin+DATlon];
		flthdg[i] = compGChdng();				// Computes GChdng
		fltdst[i] = compGCdist();				// Computes GCdist
	}
}

// Compute Heading for Flight
function compGChdng() {
	// ATAN2(SIN(RADIANS(Lon2-Lon1)) * COS(RADIANS(Lat2)), COS(RADIANS(Lat1)) * SIN(RADIANS(Lat2)) - SIN(RADIANS(Lat1)) * COS(RADIANS(Lat2)) * COS(RADIANS(Lon2-Lon1)))
	var a = Math.sin(Mod360(lon2-lon1)*DegRad) * Math.cos(lat2*DegRad);
	var b1 = Math.cos(lat1*DegRad) * Math.sin(lat2*DegRad);
	var b2 = Math.sin(lat1*DegRad) * Math.cos(lat2*DegRad) * Math.cos(Mod360(lon2-lon1)*DegRad);
	var b = b1 - b2;
//	var x = Mod360(Math.atan2(b, a) * RadDeg);	// If ATAN2 operators in correct order for three.js (opposite of Excel)
//	x = Mod360(90-GChdng);					// Must do this to get correct directon for plot
	var x = Mod360(Math.atan2(a, b) * RadDeg);	// If ATAN2 operators reversed, can save a step
return x;}

// Compute Distance for Flight
function compGCdist() {
	// ACOS(COS(RADIANS(90-Lat1)) * COS(RADIANS(90-Lat2)) + SIN(RADIANS(90-Lat1)) * SIN(RADIANS(90-Lat2)) * COS(RADIANS(Lon1-Lon2))) * 3958.756
	var a = Math.cos(Mod360(90-lat1)*DegRad) * Math.cos(Mod360(90-lat2)*DegRad);
	var b = Math.sin(Mod360(90-lat1)*DegRad) * Math.sin(Mod360(90-lat2)*DegRad);
	var c = Math.cos(Mod360(lon1-lon2)*DegRad);
	var x = Math.abs(Math.acos(a + b*c)) * 3958.756;	// 3958.756 = statute miles per radian = 
return x;}

/* Show Trip ================================================================*/

function showAllFlt() {
	// For Each Flight
	for (var i = 0; i < (flttot-1); i++) {
		showOneFlt(i);
		trpadr.add(mesh);
	}
}

// For Each Flight
function showOneFlt(j) {
	lat1 = fltDAT[j*DATlin+DATlat], lon1 = fltDAT[j*DATlin+DATlon];
	lat2 = fltDAT[j*DATlin+DATlin+DATlat], lon2 = fltDAT[j*DATlin+DATlin+DATlon];
	var positions = [];
	sgunit = Math.round(fltdst[j] * sgment);
	for (var k = 0; k <= sgunit; k++) {
		var theta = (k / segmnt) * PieVal * 2;
		positions.push(0, Math.sin(theta)*radius,-Math.cos(theta)*radius);
	}
	geometry = new THREE.BufferGeometry();
	geometry.setAttribute(
		'position',
		new THREE.BufferAttribute(new Float32Array(positions),3)
	);	
	material = new THREE.LineBasicMaterial({color: 0xffffff});
	mesh = new THREE.Line(geometry, material);
	mesh.rotation.order = "YXZ";
	mesh.rotation.y = Mod360(lon1+180) * DegRad;	// Longitude
	mesh.rotation.x = Mod360(lat1) * DegRad;	// Latitude
	mesh.rotation.z = Mod360(flthdg[j]) * DegRad;	// Bank
}

/* Show Text ================================================================*/

/* Load Arial Textures ------------------------------------------------------*/

// Load Arial Fonts
function loadFontAr() {
	for (var i = 0; i < chrtot; i ++) {
		fname = 'texture/' + i + '.png';
		chrtxt[i] = loader.load(fname);
	}
}

/* Flight Distances ---------------------------------------------------------*/

// Show Flight Distances
function showFltDst() {
	geometry = new THREE.PlaneGeometry(0.3,0.6);
	fltcnt = 0;									// Reset flight counter
	// For each flight
	for (var i = 0; i < (flttot-1); i++) {
		prntFltDst(i);							// Print distance
	}	
}

// For Each Flight - Starting Position of Label
function prntFltDst(j) {
	// Get Inputs
	ACPtch = Mod360(fltDAT[j*DATlin+DATlat]-1.5);	// lat1
	ACBank = flthdg[j];							// Starting Heading relative to vertical
	// Compute
	HXDRef = HXDACP(ACBank, ACPtch);			// Compute HXDRef using ACB and ACP
	PHBank = NapR08(ACBank, ACPtch, HXDRef);	// Compute PHBank for starting ACBank and ACPtch
	PPBank = Mod360(90 - PHBank);				// For NapR05, NapR01
	PPHed1 = NapR05(ACBank, ACPtch, HXDRef);	// Compute PPHead for ACBank and ACPtch
	PPPtch = NapR01(ACPtch, PPHed1, HXDRef);	// Compute PPPtch for ACPtch and PPHead
	// Rotate Object to Starting Position
	lon1 = Mod360(fltDAT[j*DATlin+DATlon]+180);
	fltlbY = Mod360(lon1 - PPHed1) * DegRad;	// Longitude of intersection
	fltlbZ = PPBank * DegRad;	
	fltlbX = (PPPtch * DegRad) + 0.6*fltdst[j]/3958.756;
	// Print Flight Distance
	var k = 7*j;								// Index of characters for each leg (5 per leg)
	var t = Math.floor(fltdst[j]);				// Distance to nearest integer
	// 1,000
	y = Math.floor(t/1000);
	prntFltChr(k,y+16);
	k = k + 1;
	fltlbX = fltlbX - .01;
	t = t - y * 1000;
	// 100
	y = Math.floor(t/100);
	prntFltChr(k,y+16);
	k = k + 1;
	fltlbX = fltlbX - .01;
	t = t - y * 100;
	// 10
	y = Math.floor(t/10);
	prntFltChr(k,y+16);
	k = k + 1;
	fltlbX = fltlbX - .01;
	t = t - y * 10;
	// 1
	y = t;
	prntFltChr(k,y+16);
	k = k + 1;
	fltlbX = fltlbX - .015;
	// S
	prntFltChr(k,51);
	k = k + 1;
	fltlbX = fltlbX - .012;
	// M
	prntFltChr(k,45);
}

// Print Each Character
function prntFltChr(k,p) {
	fltlbl[k] = new THREE.Object3D();
	texture = chrtxt[p];
	material = new THREE.MeshBasicMaterial({map: texture, transparent: true});
	material.depthTest = false;
	mesh = new THREE.Mesh(geometry, material);
	mesh.rotation.y = 180 * DegRad;
	mesh.rotation.z = 270 * DegRad;
	mesh.position.z = -radius;
	fltlbl[k].add(mesh);
	earobj.add(fltlbl[k]);						// Link to Earth
	fltlbl[k].rotation.order = "YZX";
	fltlbl[k].rotation.set(fltlbX,fltlbY,fltlbZ);
}

/* Place Names for Each Flight ----------------------------------------------*/

function showPlaces() {
	geometry = new THREE.PlaneGeometry(0.3,0.6);
	// For Each Place
	for (var j = 0; j < flttot; j++) {
		prntPlcNam(j);	
	}
}

// Print Place Name
function prntPlcNam(j) {
	// Starting Location
	var k = 25*j;								// Index of characters for each flight (max 5)
	lat1 = Mod360(fltDAT[j*DATlin+DATlat]-2.5) * DegRad;
	lon1 = Mod360(fltDAT[j*DATlin+DATlon]+180) * DegRad;
	var nam = fltDAT[j*DATlin+DATnam];
	var len = nam.length;
	lon1 = lon1 - 0.01*len/2;
	// For Each Character
	for (var j = 0; j < len; j++) {
		p = nam.charCodeAt(j)-32;				// Get character
		if (p == 0) lon1 = lon1 + 0.01;
		else {
			prntPlcChr(k,p);
		}
		lon1 = lon1 + 0.01;
	}
}

// Print Each Character
function prntPlcChr(k,p) {
	plclbl[k] = new THREE.Object3D();
	texture = chrtxt[p];
	material = new THREE.MeshBasicMaterial({map: texture, transparent: true});
	material.depthTest = false;
	mesh = new THREE.Mesh(geometry, material);
	mesh.rotation.y = 180 * DegRad;
	mesh.position.z = -radius;
	plclbl[k].add(mesh);
	earobj.add(plclbl[k]);						// Link to Earth
	plclbl[k].rotation.order = "YXZ";
	plclbl[k].rotation.set(lat1, lon1, 0);
}

/* Load Airplane  ===========================================================*/

// Load Airplane
function loadAirPln() {
	gltfLoader.load("models/b29_GCR.glb",
		function (gltf) {						// OnLoad function
			airobj = gltf.scene;
			airobj.rotation.order = "YZX";
			earobj.add(airobj);					// Link to Earth
			strtTakOff();						// Position at Start
		},
		null, null								// OnProgress/OnError functions
	);
}

/* 2 Render =================================================================*/

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		requestAnimationFrame(rendAll);		
		boxrot = boxrot - 3;
		Mod360(boxrot);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * Math.PI/180);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return; // Stop the function here.
	}
	// Otherwise
	requestAnimationFrame(rendAll);
	moveCamera();									// Camera position
	if (PawsOn == 0 && EndFlg == 0) {			// If not paused or ended
		moveAirPln();
		roteObjs();
		chngHUDV();
	}
	renderer.render(scene, camera);				// Render
}

/* Rotate Earth =============================================================*/

// Rotate Earth and Moon Due to Time
function roteObjs() {
	// Compute GMThrs and GMTdays
	GMThrs = GMThrs + addhrs;					// Add hours per frame
	if (GMThrs > 24) GMThrs = GMThrs - 24;
	// Compute Local Time
	var t = LCLhrs;								// Save old LCLhrs
	var tz = Mod360(ACLon1)/15+.5;
	LCLhrs = GMThrs + tz;
	if (LCLhrs > 24) LCLhrs = LCLhrs - 24;
	if (LCLhrs < 0) LCLhrs = LCLhrs + 24;
	if (t > 22 && LCLhrs < 2) DATday = DATday + 1;	// If change from pm to am
	if (LCLhrs > 22 && t < 2) DATday = DATday - 1;	// If change time zone changes am to pm
	// Convert from 24hr to AM/PM
	LCLstd = LCLhrs;
	LCLamp = "AM";
	if (LCLhrs == 12 || LCLhrs > 12) {
		LCLstd = LCLstd - 12;
		LCLamp = "PM";
	}
	if (LCLstd < 1) LCLstd = LCLstd + 12;
	// Rotate Earth Axis
	axeday = axeday+(addhrs/24);				// Add days to earth avis rotation
	if (axeday>axemax) axeday=axeday-axemax;
	axerot = Mod360(axeday*axersp);			// Rotation expressed in days
	axeobj.rotation.y = -Mod360(axerot)*DegRad;
	// Rotate Earth
	GMTday = GMThrs/24;							// GMT expressed in fractions of a day
	earrot = Mod360(GMTday*earrsp);				// Rotation expressed in days
	earobj.rotation.y = Mod360(earrot+axerot)*DegRad;
	// Rotate Moon Axis
	axmday = axmday+(addhrs/24);				// Add days to moon axis rotation
	if (axmday > axmmax) axmday = axmday-axmmax;
	axmrot = Mod360(axmday*axmrsp);				// Rotation expressed in days
	axmobj.rotation.y = Mod360(axmrot-axerot)*DegRad;
	// Orbit Moon
	munday = munday+(addhrs/24);				// Add days to moon orbit
	if (munday > munmax) munday = munday-munmax;
	munrot = Mod360(munday*munrsp);				// Orbit expressed in days
	munobj.rotation.y = Mod360(munrot+axerot-axmrot)*DegRad;	
}

/* Move Airplane ============================================================*/

// Move Airplane
function moveAirPln() {
	// Waiting On Ground
	if (ACland > 0) {
		ACland = ACland - 1;
		if (ACland == 0) {
			FLThrs = 0;							// If landed, restart flight hours
			NARwhatNode.nodeValue = "Depart";
			strtTakOff();
		}
	}
	// Flight in Progress
	else {
		if (fltsmi < fltdst[fltcnt])  {			// If still travelling
			latX = Mod360(ACLat1);				// Save old Latitude
			lonX = Mod360(ACLon1);				// Save old Longitude
			// Increase PPPtch
			PPPtch = Mod360(PPPBeg + FLThrs * airrsp);	// PPPtch
			airobj.rotation.x = PPPtch * DegRad;
			// Compute New Lat/Lon and Heading
			HXDRef = HXDPPP(PPBank, PPPtch);	// Compute new HXDRef
			PPHed2 = NapR06(PHBank, PPPtch, HXDRef);	// Compute new PPHead
			ACBank = NapR09(PHBank, PPHed2, HXDRef);	// Compute new ACBank for old PHBank and new PPHead
			ACPtch = NapR02(PHBank, PPPtch);	// Compute new ACPtch for old PHBank and new PPPtch
			//
			ACLat1 = ACPtch;					// New Latitude
			latX = Mod360(ACLat1-latX);			// Change in Lat
			ACLon1 = Mod360(PPHed2-PPHed1+lon1);	// New Longitude
			DateLine(ACLon1,lonX);				// International Date Line
			lonX = Mod360(ACLon1-lonX);			// Change in Lon
			if (ACLon1 > 180) ACLon1 = ACLon1-360;	// Convert to +/- 180
			// Compute Flight Hours
			FLThrs = FLThrs + addhrs;			// Hours in flight
			fltsmi = FLThrs * airspd;			// Total miles travelled
			TRPhrs = TRPhrs + addhrs;			// Hours in trip (only flight time)
		}
		// Flight Ended
		else {									// If reached end, start next flight
			fltcnt = fltcnt + 1;				// Next flight
			if (fltcnt < flttot-1) strtNxtFlt();
			else {
				NARwhatNode.nodeValue = "Arrive";
				NARwherNode.nodeValue = fltDAT[fltcnt*DATlin+DATnam];
				NARwhenNode.nodeValue = HHMM(LCLstd*60);
				NARampmNode.nodeValue = LCLamp;
				EndFlg = 1;
			}
		}
	}
}

function DateLine() {
	if ((lonX == 180 || lonX > 180) && ACLon1 < 180) DATday = DATday - 1;	// East to West
	if (lonX < 180 && (ACLon1 == 180 || ACLon1 > 180)) DATday = DATday + 1;	// West to East
}

// For Each Flight
function strtNxtFlt() {
	// Arrival
	ACland = fltDAT[fltcnt*DATlin+DATlnd];
	// Merely Passing Over
	if (ACland == 0) {
		NARwhatNode.nodeValue = "Pass";
		strtTakOff();
	}
	// Landed
	else {
		NARwhatNode.nodeValue = "Arrive";
		NARwherNode.nodeValue = fltDAT[fltcnt*DATlin+DATnam];
		NARwhenNode.nodeValue = HHMM(LCLstd*60);
		NARampmNode.nodeValue = LCLamp;
		airspd = 0;
		latX = 0;
		lonX = 0;
	}
}

function strtTakOff() {
	// Get Inputs
	ACPtch = fltDAT[fltcnt*DATlin+DATlat];
	ACBank = flthdg[fltcnt];					// Starting Heading relative to vertical
	// Compute
	HXDRef = HXDACP(ACBank, ACPtch);			// Compute HXDRef using ACB and ACP
	PHBank = NapR08(ACBank, ACPtch, HXDRef);	// Compute PHBank for starting ACBank and ACPtch
	PPBank = Mod360(90 - PHBank);				// For NapR05, NapR01
	PPHed1 = NapR05(ACBank, ACPtch, HXDRef);	// Compute PPHead for ACBank and ACPtch
	PPPtch = NapR01(ACPtch, PPHed1, HXDRef);	// Compute PPPtch for ACPtch and PPHead
	PPPBeg = PPPtch;							// Save beginning PPPtch
	// Rotate Object
	lon1 = fltDAT[fltcnt*DATlin+DATlon];
	airobj.rotation.y = Mod360(lon1-PPHed1+180)*DegRad;	// PPOff = Head - PPHead
	airobj.rotation.z = Mod360(90-PHBank)*DegRad;	// PHBank (relative to vertical)
	airobj.rotation.x = PPPtch*DegRad;			// PPPtch
	// Initialize
	fltsmi = 0;
	ACLat1 = ACPtch;
	ACLon1 = lon1;
	// Narrative
	NARwherNode.nodeValue = fltDAT[fltcnt*DATlin+DATnam];
	NARwhenNode.nodeValue = HHMM(LCLstd*60);
	NARampmNode.nodeValue = LCLamp;
	airspd = 250;
}

/* Move Camera ==============================================================*/

// Move Camera
function moveCamera() {
	if (PawsOn == 0 && EndFlg == 0) {
		camlat = Mod360(camlat+latX);			// Add change due to aircraft
		camlon = Mod360(camlon+lonX);			// Add change due to earth and aircraft 
	}
	camera.position.z = -camrad;
	camobj.rotation.x = camlat * DegRad;
	camobj.rotation.y = Mod360(camlon+180)*DegRad;
}

/* Subroutines ==============================================================*/

/* Compute HXD from ACB and ACP */
// Use to compute Initial PPBank and PPPtch
// If Northern Hemisphere:
// 1 = NW
// 2 = 
function HXDACP(ACB,ACP) {
	var HXD = 0;
	if (ACP == 0 || ACP > 0) {
		if (ACB == 270 || ACB > 270) HXD = 1;
		else if (ACB == 180 || ACB > 180) HXD = 8;
		else if (ACB == 90 || ACB > 90) HXD = 8;
		else HXD = 1;
	}
	else {
		if (ACB == 270 || ACB > 270) HXD = 4;	//6
		else if (ACB == 180 || ACB > 180) HXD = 5;
		else if (ACB == 90 || ACB > 90) HXD = 5;	//9
		else HXD = 4;	//10
	}	
return HXD;}

/* Compute HXD from PPB and PPP */
// Use to compute Initial Pitch and Yaw
function HXDPPP(PPB,PPP) {
	var HXD = 0;
	if (PPB == 270 || PPB > 270) {
		if (PPP > 270) HXD = 16;
		else if (PPP == 180 || PPP > 180) HXD = 15;
		else if (PPP > 90) HXD = 14;
		else {HXD = 13;}}
	else if (PPB == 180 || PPB > 180) {
		if (PPP > 270) HXD = 12;
		else if (PPP == 180 || PPP > 180) HXD = 11;
		else if (PPP > 90) HXD = 10;
		else {HXD = 9;}}
	else if (PPB == 90 || PPB > 90) {
		if (PPP > 270) HXD = 8;
		else if (PPP == 180 || PPP > 180) HXD = 7;
		else if (PPP > 90) HXD = 6;
		else {HXD = 5;}}
	else {
		if (PPP > 270) HXD = 4;
		else if (PPP == 180 || PPP > 180) HXD = 3;
		else if (PPP > 90) HXD = 2;
		else {HXD = 1;}}
return HXD;}

function NapR01(ACP,PPH,HXD) {
/* PPP=DEGREES(ACOS(COS(RADIANS(ACP))*COS(RADIANS(PPH)))) */
	var XXX = Math.cos(ACP * DegRad);
	var YYY = Math.cos(PPH * DegRad);
	var PPP = Math.acos(XXX * YYY) * RadDeg;
	/* HXDR01 */
	if (HXD == 3 ||
		HXD == 4 ||
		HXD == 7 ||
		HXD == 8 ||
		HXD == 11 ||
		HXD == 12 ||
		HXD == 15 ||
		HXD == 16)
		PPP = 360 - PPP;
//	PPP = Mod360(PPP);
	PPP = Err360(PPP);
return PPP;}

function NapR02(PHB,PPP) {
/* ACP=DEGREES(ASIN(SIN(RADIANS(PHB))*SIN(RADIANS(PPP)))) */
	var XXX = Math.sin(PHB * DegRad);
	var YYY = Math.sin(PPP * DegRad);
	var ACP = Math.asin(XXX * YYY) * RadDeg;
return ACP;}

function NapR05(ACB,ACP,HXD) {
/* PPH=DEGREES(ATAN(TAN(RADIANS(ACB))*SIN(RADIANS(ACP)))) */
	var PPH = 0;
	var XXX = Math.tan(ACB * DegRad);
	var YYY = Math.sin(ACP * DegRad);
	PPH = Math.atan2(XXX * YYY,1) * RadDeg;
	/* HXDR05 */
	if (HXD == 2 ||
		HXD == 3 ||
		HXD == 6 ||
		HXD == 7 ||
		HXD == 10 ||
		HXD == 11 ||
		HXD == 14 ||
		HXD == 15) 
		PPH = PPH + 180;
	PPH = Mod360(PPH);							// don't round or err correct (intermediate function)
return PPH;}

function NapR06(PHB,PPP,HXD) {
/* PPH=DEGREES(ATAN(COS(RADIANS(PHB))*TAN(RADIANS(PPP)))) */
	var PPH = 0;
	var XXX = Math.cos(PHB * DegRad);
	var YYY = Math.tan(PPP * DegRad);
	PPH = Math.atan2(XXX * YYY,1) * RadDeg;
	/* HXDR06 */
	if (HXD == 2 ||
		HXD == 3 ||
		HXD == 6 ||
		HXD == 7 ||
		HXD == 10 ||
		HXD == 11 ||
		HXD == 14 ||
		HXD == 15)
		PPH = PPH + 180;
	PPH = Mod360(PPH);							// don't round or err correct (intermediate function)
return PPH;}

function NapR08(ACB,ACP,HXD) {
/* PHB=DEGREES(ACOS(SIN(RADIANS(ACB))*COS(RADIANS(ACP)))) */
	var XXX = Math.sin(ACB * DegRad);
	var YYY = Math.cos(ACP * DegRad);
	var PHB = Math.acos(XXX * YYY) * RadDeg;
	/* HXDR08 */
	if (HXD > 4 && HXD < 13) PHB = 360 - PHB;
//	PHB = Mod360(PHB);
	PHB = Err360(PHB);
return PHB;}

function NapR09(PHB,PPH,HXD) {
/* ACB=DEGREES(ACOS(SIN(RADIANS(PHB))*COS(RADIANS(PPH)))) */
	var XXX = Math.sin(PHB * DegRad);
	var YYY = Math.cos(PPH * DegRad);
	var ACB = Math.acos(XXX * YYY) * RadDeg;
	/* HXDR09 */
	if (HXD > 8) ACB = 360 - ACB;
//	ACB = Mod360(ACB);
	ACB = Err360(ACB);							// eliminating this causes heading = heading + 180 on mouse move
return ACB;}

/* Subroutines ==============================================================*/

// Convert degrees to 360
function Mod360(deg) {
	if (deg < 0) deg = deg + 360;
	else if (deg == 360 || deg > 360) deg = deg - 360;
return deg;}

/* Converts degrees to 360 and avoid err */
function Err360(deg) {
	if (deg < 0) deg = deg + 360;
	else if (deg == 360 || deg > 360) deg = deg - 360;
	if (deg == 0 ||
		deg == 90 ||
		deg == 180 ||
		deg == 270) {
		deg = deg + SmallV;
	}
return deg;}

/* 3 Outputs =================================================================*/

// Change HUD Values
function chngHUDV() {
	TYM_DAYNode.nodeValue = DATday;
	TYM_MONNode.nodeValue = Month(DATmon);
	TYM_ANNNode.nodeValue = DATann;
	TYM_GMTNode.nodeValue = HHMM(GMThrs*60);
	TYM_LCLNode.nodeValue = HHMM(LCLstd*60);
	TYM_AMPNode.nodeValue = LCLamp;	
	AC_SpedNode.nodeValue = airspd.toFixed(0);
	AC_Lat1Node.nodeValue = ACLat1.toFixed(2);
	AC_Lon1Node.nodeValue = ACLon1.toFixed(2);
	AC_BankNode.nodeValue = ACBank.toFixed(2);
	TYM_FltNode.nodeValue = HHMM(FLThrs*60);
	TYM_TrpNode.nodeValue = HHMM(TRPhrs*60);
}

// Print HHMM Format
function HHMM(x) {
    var hours   = Math.floor(x / 60);
    var minutes = Math.floor(x - (hours * 60));
    if (hours   < 10) {hours   = "0"+hours;}
    if (minutes < 10) {minutes = "0"+minutes;}
    return hours+':'+minutes;
}

// Print Month
function Month(x) {
    var m = monDAT[x-1];
    return m;
}

// Info On
function onInfo(){
	On_Info02Node.nodeValue = "Drag Mouse to Orbit Earth";
	On_Info03Node.nodeValue = "Scroll to Zoom In and Out";
	On_Info04Node.nodeValue = "Press P to Pause";
}

// Info Off
function noInfo(){
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
}

/* 4 Inputs ================================================================ */

// Keyboard - Down
function onDocumentKeyDown(event) {
	var keyCode = event.which;
	// Toggle Info
	if (event.keyCode == K_Info) {
		if (InfoOn == 0) {
			InfoOn = 1;
			onInfo();
		}
		else {
			InfoOn = 0;
			noInfo();
		}
	}
	// Toggle Pause
	if (event.keyCode == K_Paws) {
		if (PawsOn < 1) PawsOn = 1;
		else PawsOn = 0;
	}
}

// Keyboard - Up
function onDocumentKeyUp(event) {
	var keyCode = event.which;
}

function onDocumentMouseDown(event) {
	event.preventDefault();
	isUserInteracting = true;
	onPointerDownPointerX = event.clientX;
	onPointerDownPointerY = event.clientY;
	onPointerDownLon = camlon;
	onPointerDownLat = camlat;
}

function onDocumentMouseUp(event) {
	isUserInteracting = false;
}

function onDocumentMouseMove(event) {
	if (isUserInteracting === true) {
		camlon = (onPointerDownPointerX - event.clientX) * 0.2 + onPointerDownLon;
		camlon = Mod360(camlon);
		camlat = (event.clientY - onPointerDownPointerY) * 0.2 + onPointerDownLat;
		camlat = Math.max(-85, Math.min(85, camlat));
	}
}

function onDocumentMouseWheel(event) {
	camrad = camrad + event.deltaY * 0.05;
	camrad = Math.max(50, Math.min(140, camrad));
}

function onDocumentTouchStart(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		onPointerDownPointerX = event.touches[0].clientX;
		onPointerDownPointerY = event.touches[0].clientY;
		onPointerDownLon = camlon;
		onPointerDownLat = camlat;
	}
	// Dual Touch
	if (event.touches.length == 2) {
		_state = STATE.TOUCH_ZOOM_PAN;
		var dx = event.touches[0].clientX - event.touches[1].clientX;
		var dy = event.touches[0].clientY - event.touches[1].clientY;
		_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );
    }
}

function onDocumentTouchMove(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		camlon = (onPointerDownPointerX - event.touches[0].clientX) * 0.2 + onPointerDownLon;
		camlon = Mod360(camlon);
		camlat = (event.touches[0].clientY - onPointerDownPointerY) * 0.2 + onPointerDownLat;
		camlat = Math.max(-85, Math.min(85, camlat));
	}
	// Dual Touch
	if (event.touches.length == 2) {
		var dx = event.touches[0].clientX - event.touches[1].clientX;
		var dy = event.touches[0].clientY - event.touches[1].clientY;
		_touchZoomDistanceEnd = Math.sqrt(dx*dx+dy*dy);	
		camrad = camrad + (_touchZoomDistanceEnd-_touchZoomDistanceStart) * 0.05;
		camrad = Math.max(50, Math.min(140, camrad));
//		var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
		_touchZoomDistanceStart = _touchZoomDistanceEnd;
//		setZoom(camera.fov * factor);
    }
}

function onDocumentTouchEnd(event) {
	_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
}

function setZoom(fov){
    camera.fov = fov;
    if(camera.fov < 30) camera.fov = 30;
    if(camera.fov > 100) camera.fov = 100;
    camera.updateProjectionMatrix();
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}

</script>
<!-- WiredMinds eMetrics tracking with Enterprise Edition V5.4 START -->
<script type='text/javascript' src='https://count.carrierzone.com/app/count_server/count.js'></script>
<script type='text/javascript'><!--
wm_custnum='7fbb1a0760ecad07';
wm_page_name='Globe.html';
wm_group_name='/services/webpages/p/h/philcrowther.com/public/WebGL/Space/Earth';
wm_campaign_key='campaign_id';
wm_track_alt='';
wiredminds.count();
// -->
</script>
<!-- WiredMinds eMetrics tracking with Enterprise Edition V5.4 END -->
</body>
</html>
